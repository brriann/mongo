
https://docs.mongodb.com/drivers/csharp

###
### INTRO/SETUP
###

Nuget package: MongoDB.Driver

var client = new MongoClient("uri_to_mongodb")
var db = client.GetDatabase("db_name")
var collection = db.GetCollection<BsonDocument>("collection_name")

var result = collection.Find("{id: 1234}").FirstOrDefault()


###
### USING THE DRIVER
###

integrating MQL into a C# Find() query
var result = collection.Find("{id: 1234}").FirstOrDefault()
*not type safe!*

using BsonDocuments
var result = collection.Find(new BsonDocument("id", "1234").FirstOrDefault()

*every {$set: {this: that}} in MQL is a nested BsonDocument!
  var filter = new BsonDocument("Id", 1234)
  var update = new BsonDocument("$set", new BsonDocument("price", 700))
  var options = new UpdateOptions {IsUpsert = true};

The driver's Builders class
var builder = Builders<BsonDocument>.Filter;
var filter = builder.Eq("id", "1234")

or...

var f = Builders<Guitar>.Filter.Eq(g => g.Id, 1234)
var b = Builders<Guitar>.Update.Set(g => g.Price, 700)
guitarsCollection.UpdateOne(f, b)

The above ways (string query, nested BsonDocuments, and Builders) - don't protect against Field name correctness.

***
4th approach: LINQ, used with mapping Classes. .Find() with MongoDriver vs .Where() in LINQ
***

Mongo Driver maps _id in DB to Id in C#.  (using [BsonId])
Also, maps field1 to Field1, fieldName2 to FieldName2, etc. (using [BsonElement("fieldName2")]

var filteredCollection = db.GetCollection<Guitar>("guitars").Find(g => g.Price > 400).ToList()

.Find(g => g.Price > 400)
.InsertOne(new Guitar {Id = 6, Price = 950,...})
.ReplaceOne(filter, replacement)
.UpdateOne(filter, update, options)
.DeleteOne(g => g.Id == 1234)


###
### SYNC / ASYNC PROGRAMMING WITH MONGO DRIVER
###

https://docs.microsoft.com/en-us/archive/msdn-magazine/2014/october/async-programming-introduction-to-async-await-on-asp-net
https://docs.microsoft.com/en-us/aspnet/web-forms/overview/performance-and-caching/using-asynchronous-methods-in-aspnet-45

ASP.NET applications have a THREAD POOL
sync: if a thread is making a DB request, that thread is locked down until the external resource responds
async: thread makes call to external resource (DB), and is immediately returned to the thread pool.
  -when the request/response comes back from external resource, any thread from thread pool can handle it

Method signatures:

public ActionResult MyMethod(string Id) {...}
vs
public async Task<ActionResult> MyMethodAsync(string Id, CancellationToken cancelToken = default) {...}

MongoDB Driver usage:

return await collection.Find().FirstOrDefaultAsync()


###
### BASIC READS
###

var filter = new BsonDocument("title", "Armageddon")
var betterFilter = Builders<Movie>.Filter.Eq(m => m.Title, "Armageddon")

var movies = await _moviesCollection.Find<Movie>(betterFilter).ToListAsync()

PROJECTION:

var projectionFilter = Builders<Movie>.Projection
  .Include(m => m.Title)
  .Include(m => m.Year)
  .Include(m => m.Cast)
  .Exclude(m => m.Id);

var movieProjected = await _moviesCollection
  .Find<Movie>(betterFilter)
  .Project<Movie>(projectionFilter)
  .FirstOrDefaultAsync()


###
### ADVANCED READS
###

var filter = Builders<Movie>.Filter.In("cast", new string[] {"Tom Hanks"})

var movieLimited = await _moviesCollection
  .Find<Movie>(filter)
  .Limit(2)
  .ToListAsync()
  
implement paging:

var movieLimited = await _moviesCollection
.Find<Movie>(filter)
.Sort(new BsonDocument("year", 1)) // or, Builders<Movies>.Sort.Ascending(m => m.Year)
.Limit(moviesPerPage)
.Skip(pageNumber * moviesPerPage)
.ToListAsync()
  

###
###
###



###
###
###
